const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/InteractiveContent-Dtbg8Da8.js","assets/index-B-HRXyag.js","assets/index-DxoOJMoB.css","assets/Gltf-DtB1V7-b.js","assets/events-e3cb66e2.esm-DFm8s4y8.js","assets/BufferGeometryUtils-7-XupBXG.js","assets/bundle-mjs-BTmSotT-.js","assets/index-87ra0BQW.js"])))=>i.map(i=>d[i]);
import{r as n,C as je,R,j as O,_ as we}from"./index-B-HRXyag.js";import{_ as Ee,C as Ce}from"./extends-C1sQzDBQ.js";import{u as We,d as Re,q as Oe,c as k,V as Te,x as oe,O as ie,ak as $e,al as _}from"./events-e3cb66e2.esm-DFm8s4y8.js";const T=new k,B=new k,Fe=new k,ne=new Te;function He(e,t,r){const s=T.setFromMatrixPosition(e.matrixWorld);s.project(t);const i=r.width/2,a=r.height/2;return[s.x*i+i,-(s.y*a)+a]}function Le(e,t){const r=T.setFromMatrixPosition(e.matrixWorld),s=B.setFromMatrixPosition(t.matrixWorld),i=r.sub(s),a=t.getWorldDirection(Fe);return i.angleTo(a)>Math.PI/2}function Ve(e,t,r,s){const i=T.setFromMatrixPosition(e.matrixWorld),a=i.clone();a.project(t),ne.set(a.x,a.y),r.setFromCamera(ne,t);const x=r.intersectObjects(s,!0);if(x.length){const P=x[0].distance;return i.distanceTo(r.ray.origin)<P}return!0}function _e(e,t){if(t instanceof ie)return t.zoom;if(t instanceof oe){const r=T.setFromMatrixPosition(e.matrixWorld),s=B.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,a=r.distanceTo(s);return 1/(2*Math.tan(i/2)*a)}else return 1}function ke(e,t,r){if(t instanceof oe||t instanceof ie){const s=T.setFromMatrixPosition(e.matrixWorld),i=B.setFromMatrixPosition(t.matrixWorld),a=s.distanceTo(i),x=(r[1]-r[0])/(t.far-t.near),P=r[1]-x*t.far;return Math.round(x*a+P)}}const N=e=>Math.abs(e)<1e-10?0:e;function ae(e,t,r=""){let s="matrix3d(";for(let i=0;i!==16;i++)s+=N(t[i]*e.elements[i])+(i!==15?",":")");return r+s}const ze=(e=>t=>ae(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ae=(e=>(t,r)=>ae(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function De(e){return e&&typeof e=="object"&&"current"in e}const Ie=n.forwardRef(({children:e,eps:t=.001,style:r,className:s,prepend:i,center:a,fullscreen:x,portal:P,distanceFactor:w,sprite:ce=!1,transform:h=!1,occlude:c,onOcclude:Z,castShadow:le,receiveShadow:ue,material:de,geometry:q,zIndexRange:$=[16777271,0],calculatePosition:G=He,as:fe="div",wrapperClass:z,pointerEvents:J="auto",...v},K)=>{const{gl:Q,camera:l,scene:U,size:d,raycaster:me,events:he,viewport:xe}=We(),[u]=n.useState(()=>document.createElement(fe)),A=n.useRef(null),m=n.useRef(null),X=n.useRef(0),F=n.useRef([0,0]),E=n.useRef(null),D=n.useRef(null),S=(P==null?void 0:P.current)||he.connected||Q.domElement.parentNode,p=n.useRef(null),H=n.useRef(!1),L=n.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&De(c[0]),[c]);n.useLayoutEffect(()=>{const f=Q.domElement;c&&c==="blending"?(f.style.zIndex=`${Math.floor($[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[c]),n.useLayoutEffect(()=>{if(m.current){const f=A.current=je.createRoot(u);if(U.updateMatrixWorld(),h)u.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const o=G(m.current,l,d);u.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${o[0]}px,${o[1]}px,0);transform-origin:0 0;`}return S&&(i?S.prepend(u):S.appendChild(u)),()=>{S&&S.removeChild(u),f.unmount()}}},[S,h]),n.useLayoutEffect(()=>{z&&(u.className=z)},[z]);const Y=n.useMemo(()=>h?{position:"absolute",top:0,left:0,width:d.width,height:d.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...x&&{top:-d.height/2,left:-d.width/2,width:d.width,height:d.height},...r},[r,a,x,d,h]),ve=n.useMemo(()=>({position:"absolute",pointerEvents:J}),[J]);n.useLayoutEffect(()=>{if(H.current=!1,h){var f;(f=A.current)==null||f.render(n.createElement("div",{ref:E,style:Y},n.createElement("div",{ref:D,style:ve},n.createElement("div",{ref:K,className:s,style:r,children:e}))))}else{var o;(o=A.current)==null||o.render(n.createElement("div",{ref:K,style:Y,className:s,children:e}))}});const j=n.useRef(!0);Re(f=>{if(m.current){l.updateMatrixWorld(),m.current.updateWorldMatrix(!0,!1);const o=h?F.current:G(m.current,l,d);if(h||Math.abs(X.current-l.zoom)>t||Math.abs(F.current[0]-o[0])>t||Math.abs(F.current[1]-o[1])>t){const y=Le(m.current,l);let g=!1;L&&(Array.isArray(c)?g=c.map(b=>b.current):c!=="blending"&&(g=[U]));const C=j.current;if(g){const b=Ve(m.current,l,me,g);j.current=b&&!y}else j.current=!y;C!==j.current&&(Z?Z(!j.current):u.style.display=j.current?"block":"none");const V=Math.floor($[0]/2),ge=c?L?[$[0],V]:[V-1,0]:$;if(u.style.zIndex=`${ke(m.current,l,ge)}`,h){const[b,te]=[d.width/2,d.height/2],I=l.projectionMatrix.elements[5]*te,{isOrthographicCamera:re,top:pe,left:ye,bottom:be,right:Me}=l,Pe=ze(l.matrixWorldInverse),Se=re?`scale(${I})translate(${N(-(Me+ye)/2)}px,${N((pe+be)/2)}px)`:`translateZ(${I}px)`;let M=m.current.matrixWorld;ce&&(M=l.matrixWorldInverse.clone().transpose().copyPosition(M).scale(m.current.scale),M.elements[3]=M.elements[7]=M.elements[11]=0,M.elements[15]=1),u.style.width=d.width+"px",u.style.height=d.height+"px",u.style.perspective=re?"":`${I}px`,E.current&&D.current&&(E.current.style.transform=`${Se}${Pe}translate(${b}px,${te}px)`,D.current.style.transform=Ae(M,1/((w||10)/400)))}else{const b=w===void 0?1:_e(m.current,l)*w;u.style.transform=`translate3d(${o[0]}px,${o[1]}px,0) scale(${b})`}F.current=o,X.current=l.zoom}}if(!L&&p.current&&!H.current)if(h){if(E.current){const o=E.current.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const{isOrthographicCamera:y}=l;if(y||q)v.scale&&(Array.isArray(v.scale)?v.scale instanceof k?p.current.scale.copy(v.scale.clone().divideScalar(1)):p.current.scale.set(1/v.scale[0],1/v.scale[1],1/v.scale[2]):p.current.scale.setScalar(1/v.scale));else{const g=(w||10)/400,C=o.clientWidth*g,V=o.clientHeight*g;p.current.scale.set(C,V,1)}H.current=!0}}}else{const o=u.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const y=1/xe.factor,g=o.clientWidth*y,C=o.clientHeight*y;p.current.scale.set(g,C,1),H.current=!0}p.current.lookAt(f.camera.position)}});const ee=n.useMemo(()=>({vertexShader:h?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[h]);return n.createElement("group",Ee({},v,{ref:m}),c&&!L&&n.createElement("mesh",{castShadow:le,receiveShadow:ue,ref:p},q||n.createElement("planeGeometry",null),de||n.createElement("shaderMaterial",{side:Oe,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),Ne=e=>e;function Be(e,t=Ne){const r=R.useSyncExternalStore(e.subscribe,R.useCallback(()=>t(e.getState()),[e,t]),R.useCallback(()=>t(e.getInitialState()),[e,t]));return R.useDebugValue(r),r}const se=e=>{const t=$e(e),r=s=>Be(t,s);return Object.assign(r,t),r},Ze=e=>e?se(e):se;let W=0;const qe=Ze(e=>(_.onStart=(t,r,s)=>{e({active:!0,item:t,loaded:r,total:s,progress:(r-W)/(s-W)*100})},_.onLoad=()=>{e({active:!1})},_.onError=t=>e(r=>({errors:[...r.errors,t]})),_.onProgress=(t,r,s)=>{r===s&&(W=s),e({active:!0,item:t,loaded:r,total:s,progress:(r-W)/(s-W)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0})),Ge=()=>{const{progress:e}=qe();return O.jsxs(Ie,{center:!0,className:"text-xl font-normal text-center",children:[e,"% Loaded"]})},Je=R.lazy(()=>we(()=>import("./InteractiveContent-Dtbg8Da8.js"),__vite__mapDeps([0,1,2,3,4,5,6,7]))),Xe=({isMobile:e})=>O.jsx(Ce,{camera:{position:[0,1,5],fov:60},children:O.jsx(n.Suspense,{fallback:O.jsx(Ge,{}),children:O.jsx(Je,{section:"3d",isMobile:e})})});export{Xe as default};
