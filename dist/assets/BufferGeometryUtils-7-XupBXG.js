import{R as N,c as l,aG as U,bb as z,ba as E,b9 as R}from"./events-e3cb66e2.esm-DFm8s4y8.js";const y=parseInt(N.replace(/\D+/g,""));function H(r,u){if(u===z)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),r;if(u===E||u===R){let o=r.getIndex();if(o===null){const t=[],m=r.getAttribute("position");if(m!==void 0){for(let s=0;s<m.count;s++)t.push(s);r.setIndex(t),o=r.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const f=o.count-2,e=[];if(o)if(u===E)for(let t=1;t<=f;t++)e.push(o.getX(0)),e.push(o.getX(t)),e.push(o.getX(t+1));else for(let t=0;t<f;t++)t%2===0?(e.push(o.getX(t)),e.push(o.getX(t+1)),e.push(o.getX(t+2))):(e.push(o.getX(t+2)),e.push(o.getX(t+1)),e.push(o.getX(t)));e.length/3!==f&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=r.clone();return a.setIndex(e),a.clearGroups(),a}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",u),r}function k(r,u=Math.PI/3){const o=Math.cos(u),f=(1+1e-10)*100,e=[new l,new l,new l],a=new l,t=new l,m=new l,s=new l;function D(n){const b=~~(n.x*f),i=~~(n.y*f),d=~~(n.z*f);return`${b},${i},${d}`}const A=r.index?r.toNonIndexed():r,c=A.attributes.position,x={};for(let n=0,b=c.count/3;n<b;n++){const i=3*n,d=e[0].fromBufferAttribute(c,i+0),g=e[1].fromBufferAttribute(c,i+1),T=e[2].fromBufferAttribute(c,i+2);a.subVectors(T,g),t.subVectors(d,g);const p=new l().crossVectors(a,t).normalize();for(let w=0;w<3;w++){const B=e[w],h=D(B);h in x||(x[h]=[]),x[h].push(p)}}const G=new Float32Array(c.count*3),I=new U(G,3,!1);for(let n=0,b=c.count/3;n<b;n++){const i=3*n,d=e[0].fromBufferAttribute(c,i+0),g=e[1].fromBufferAttribute(c,i+1),T=e[2].fromBufferAttribute(c,i+2);a.subVectors(T,g),t.subVectors(d,g),m.crossVectors(a,t).normalize();for(let p=0;p<3;p++){const w=e[p],B=D(w),h=x[B];s.set(0,0,0);for(let V=0,M=h.length;V<M;V++){const X=h[V];m.dot(X)>o&&s.add(X)}s.normalize(),I.setXYZ(i+p,s.x,s.y,s.z)}}return A.setAttribute("normal",I),A}export{H as a,k as t,y as v};
